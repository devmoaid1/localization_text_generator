import 'dart:io';

import 'package:code_builder/code_builder.dart';
import 'package:dart_style/dart_style.dart';
import 'package:glob/glob.dart';
import 'package:glob/list_local_fs.dart';
import 'package:yaml/yaml.dart';

class GenerateDartClasses {
  final DartEmitter emitter = DartEmitter();
  Set<String> keys = {};
  late final String _packageName;
  GenerateDartClasses(String currentDirectory){
    _getPackageName(currentDirectory);
  }
  String  importPackageNameFor({required String filename}) =>'''import 'package:$_packageName/generated/$filename.dart';\n''';
  void addKey(String value) => keys.add(value);

  String _generateEnumAndExtension() {
    final enumClass = Enum((builder) => builder
      ..name = 'JsonKeys'
      ..values.addAll(keys.map((e) => EnumValue((builder) => builder..name = e)))
      ..docs.add('///This is all keys of json generated by Localization_text_generator'));
    final extension = Extension((builder) => builder
      ..name = 'JsonStringMapper'
      ..methods.add(Method((builder) => builder
        ..name = 'get'
        ..lambda = true
        ..body = Code('''
    JsonTextMapper().json[name] ?? ''
    ''')))
      ..on = Reference('JsonKeys'));
    return DartFormatter().format('''
      // ignore_for_file: constant_identifier_names
      /// This file is generated by localization text generator, please don't edit. 
        import './json_text_mapper.g.dart';

    ${extension.accept(emitter)}
    ${enumClass.accept(emitter)}''');
  }

  String _generateModel() {
    final modelClass = Class((builder) => builder
      ..docs.add('/// Model Class [JsonTextMapper] contains method to get file from assets or saved file')

      ///Class Name (JsonTextMapper)
      ..name = 'JsonTextMapper'

      /// Constructors
      ..constructors.add(

          /// Factory of Singleton
          Constructor((builder) => builder
            ..factory = true
            // ..name = 'JsonTextMapper'
            ..body = Code('return _jsonTextMapper;')))

      /// Class Fields
      ..fields.addAll([
        /// Singleton private reference
        Field((builder) => builder
          ..name = '_jsonTextMapper'
          ..assignment = Code('JsonTextMapper._internal()')
          ..modifier = FieldModifier.final$
          ..static = true
          ..type = Reference('JsonTextMapper')
        ),

        /// Map<String, String> _json
        Field((builder) => builder
          ..name = 'json'
          ..type = Reference('Map<String, String>')
          ..assignment = Code('{}'))
      ])
      ..methods.addAll([
        /// Internal Reference for Singleton => JsonTextMapper._internal();
        Method((builder) => builder..name = 'JsonTextMapper._internal'),
        Method((builder) => builder..modifier=MethodModifier.async
          ..name = 'init'
          ..body = Code('''
           final supportDir = await getApplicationSupportDirectory();
           final path = supportDir.path + filePath;
           late final String fileData;
            if (File(path).existsSync()) {
           fileData = File(path).readAsStringSync();
             }
            else {
             fileData = await rootBundle.loadString(assetsPath);
                 }
            json = jsonDecode(fileData);
          ''')
          ..optionalParameters.addAll([
            Parameter((builder) => builder
              ..required = false
              ..type = Reference('String')
              ..name = 'assetsPath'
              ..named = true
              ..defaultTo = Code("'assets/generated/strings.json'")),
            Parameter((builder) => builder
              ..required = false
              ..type = Reference('String')
              ..named = true
              ..name = 'filePath'
              ..defaultTo = Code("'data/strings.json'")),
          ]))
      ]));
    return DartFormatter().format('''
    import 'dart:convert';
    import 'dart:io';
    
    import 'package:flutter/services.dart';
    import 'package:path_provider/path_provider.dart';

    ${modelClass.accept(emitter)}
    ''');
  }
  void _getPackageName(String currentDirectory){
    try{
      List<FileSystemEntity> pubspecYamls = Glob('pubspec.yaml').listSync();
      final File pubspecYaml = (pubspecYamls.where((e) => e is File && e.path.split('/').last == 'pubspec.yaml').first) as File;
      _packageName = loadYaml(pubspecYaml.readAsStringSync())['name'] ?? '';
    }catch(e){
      _packageName='';
    }
  }
  (String model, String enumKeys) run() {
    assert(keys.isNotEmpty, 'Key cannot be zero');
    if (keys.length == 1) assert(keys.first.isNotEmpty, 'Key cannot be empty');
    return (_generateModel(), _generateEnumAndExtension());
  }
}

/// Example
// class JsonTextMapper {
//   Map<String, String> json = {};
//   static final JsonTextMapper _jsonTextMapper = JsonTextMapper._internal();
//
//   factory JsonTextMapper() {
//     return _jsonTextMapper;
//   }
//
//   JsonTextMapper._internal();
//
//   Future<void> init(
//       {String assetsPath = 'assets/generated/strings.json', String filePath = 'data/strings.json'}) async {
//     final supportDir = await getApplicationSupportDirectory();
//     final path = supportDir.path + filePath;
//     late final String fileData;
//     if (File(path).existsSync()) {
//       fileData = File(path).readAsStringSync();
//     } else {
//       fileData = await rootBundle.loadString(assetsPath);
//     }
//     json = jsonDecode(fileData);
//   }
//
//
//
//   void initFromFile(String path) => json = jsonDecode(File(path).readAsStringSync());
// }
//
// extension JsonStringMapper on JsonKeys {
//   String fromJson() => JsonTextMapper().json[name] ?? '';
// }
//
// enum JsonKeys { firstL }
